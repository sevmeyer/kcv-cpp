// kcv-cpp 0.1.0
// A lightweight KCV library for C++17
// https://github.com/sevmeyer/kcv-cpp
//
// Copyright 2020 Severin Meyer
// Distributed under the Boost Software License 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#ifndef KCV_KCV_HPP_INCLUDED
#define KCV_KCV_HPP_INCLUDED


#include <cerrno>       // errno
#include <cmath>        // isinf, isnan
#include <cstddef>      // size_t
#include <cstdint>      // uint32_t
#include <cstdlib>      // strtod
#include <cstring>      // memcpy
#include <algorithm>    // adjacent_find, clamp, lower_bound, max, min, sort
#include <array>        // array
#include <charconv>     // from_chars, to_chars
#include <locale>       // locale
#include <limits>       // numeric_limits
#include <sstream>      // fixed, ostringstream
#include <string>       // string
#include <string_view>  // string_view
#include <system_error> // errc
#include <type_traits>  // enable_if, is_floating_point, is_integral, is_unsigned
#include <utility>      // move
#include <vector>       // vector


namespace kcv    {
namespace detail {


// .----------.   .-----------.   .-------------.
// | Document |-->|  Buffer   |-->| std::string |
// '----------'   '-----------'   '-------------'
//                  ^       |           ^
//                  .       v           .
// .----------.     .  .-------------.  .
// |   Item   |- - -   | std::vector |  .
// '----------'     .  '-------------'  .
//      |           .       |           .
//      |           v       v           .
//      |         .-----------.         .
//      |         |  Lookup   |         .
//      |         '-----------'         .
//      |                               .
//      |         .-----------.   .--------.
//      '-------->| Tokenizer |-->| Stream |
//                '-----------'   '--------'
// ----> Ownership
// - - > Reference


using Size = std::uint32_t;

template<typename T>
using IsInt = typename std::enable_if_t<
	std::is_integral_v<T>, bool>;

template<typename T>
using IsFloat = typename std::enable_if_t<
	std::is_floating_point_v<T>, bool>;


// Character tests
// ---------------

inline bool isWs(char c)
{
	return c == ' '
		|| c == '\t'
		|| c == '\n'
		|| c == '\r';
}

inline bool isNonNlWs(char c)
{
	return c == ' '
		|| c == '\t'
		|| c == '\r';
}

inline bool isDigit(char c)
{
	return ('0' <= c && c <= '9');
}

inline bool isHexdig(char c)
{
	return ('0' <= c && c <= '9')
		|| ('A' <= c && c <= 'F')
		|| ('a' <= c && c <= 'f');
}

inline bool isAlpha(char c)
{
	return ('a' <= c && c <= 'z')
		|| ('A' <= c && c <= 'Z');
}

inline bool isKeyChar(char c)
{
	return ('a' <= c && c <= 'z')
		|| ('A' <= c && c <= 'Z')
		|| ('0' <= c && c <= '9')
		|| c == '-'
		|| c == '.'
		|| c == '_';
}

inline bool isKey(std::string_view view)
{
	if (view.empty())
		return false;

	if (!isAlpha(view.front()))
		return false;

	for (char c : view.substr(1))
		if (!isKeyChar(c))
			return false;

	return true;
}


// Value formatters
// ----------------

template<typename T>
struct IntValue
{
	T value;
	bool isHex;
	int width;
};

template<typename T>
struct FloatValue
{
	T value;
	int precision;
	bool isFixed;
};

struct Whitespace
{
	char value;
	int count;
};

// Writes a zero-padded hexadecimal integer.
template<typename T>
inline IntValue<T> hex(T value, int width = 1)
{
	return {value, true, width};
}

// Writes a floating-point value with a fixed
// number of digits after the decimal point.
template<typename T>
inline FloatValue<T> fixed(T value, int precision = 6)
{
	return {value, precision, true};
}

// Writes a floating-point value in general notation.
template<typename T>
inline FloatValue<T> general(T value, int precision = 6)
{
	return {value, precision, false};
}

// Writes newlines.
inline Whitespace nl(int count = 1)
{
	return {'\n', count};
}

// Writes spaces.
inline Whitespace sp(int count = 1)
{
	return {' ', count};
}

// Writes tabs.
inline Whitespace tab(int count = 1)
{
	return {'\t', count};
}


// Private types
// -------------

class Stream
{
	public:

		Stream(const char* data, Size begin, Size end) :
			data_{data},
			pos_{begin},
			end_{end}
		{}

		const char* data() const
		{
			return data_;
		}

		Size pos() const
		{
			return pos_;
		}

		bool isEof() const
		{
			return pos_ == end_;
		}

		// Bounds-checked
		char peek() const
		{
			return pos_ < end_ ? data_[pos_] : 0;
		}

		// Bounds-checked
		char peek(Size offset) const
		{
			return (end_ - pos_ > offset) ? data_[pos_ + offset] : 0;
		}

		// Bounds-checked
		void skip(Size count = 1)
		{
			pos_ += std::min(end_ - pos_, count);
		}

		bool accept(char c)
		{
			if (peek() != c)
				return false;
			skip();
			return true;
		}

		bool acceptDigits()
		{
			if (!isDigit(peek()))
				return false;
			skip();
			while (isDigit(peek()))
				skip();
			return true;
		}

		bool acceptHexdigs()
		{
			if (!isHexdig(peek()))
				return false;
			skip();
			while (isHexdig(peek()))
				skip();
			return true;
		}

		bool acceptHexdigs(Size count)
		{
			while (count-- > 0)
			{
				if (!isHexdig(peek()))
					return false;
				skip();
			}
			return true;
		}

		bool acceptScalar()
		{
			// https://www.unicode.org/versions/Unicode12.1.0/
			// Table 3-7. Well-Formed UTF-8 Byte Sequences
			//
			// Code Points    Byte1  Byte2  Byte3  Byte4
			// 000000-00007F  00-7F
			// 000080-0007FF  C2-DF  80-BF
			// 000800-000FFF  E0     A0-BF  80-BF
			// 001000-00CFFF  E1-EC  80-BF  80-BF
			// 00D000-00D7FF  ED     80-9F  80-BF
			// 00E000-00FFFF  EE-EF  80-BF  80-BF
			// 010000-03FFFF  F0     90-BF  80-BF  80-BF
			// 040000-0FFFFF  F1-F3  80-BF  80-BF  80-BF
			// 100000-10FFFF  F4     80-8F  80-BF  80-BF

			unsigned char b{static_cast<unsigned char>(peek())};

			if (b <= 0x7F)
			{
				skip();
				return true;
			}

			unsigned char min{0x80};
			unsigned char max{0xBF};
			unsigned char count{1};

			if      (0xC2 <= b && b <= 0xDF) { count = 2; }
			else if (0xE0 == b) { min = 0xA0; count = 3; }
			else if (0xE1 <= b && b <= 0xEC) { count = 3; }
			else if (0xED == b) { max = 0x9F; count = 3; }
			else if (0xEE <= b && b <= 0xEF) { count = 3; }
			else if (0xF0 == b) { min = 0x90; count = 4; }
			else if (0xF1 <= b && b <= 0xF3) { count = 4; }
			else if (0xF4 == b) { max = 0x8F; count = 4; }
			else return false;

			skip();
			while (--count > 0)
			{
				b = static_cast<unsigned char>(peek());
				if (b < min || max < b)
					return false;
				min = 0x80;
				max = 0xBF;
				skip();
			}

			return true;
		}

		bool acceptEscape()
		{
			switch (peek())
			{
				case '\\':
				case '"':
				case 'n':
				case 'r':
				case 't': skip(); return true;
				case 'u': skip(); return acceptHexdigs(4);
				case 'U': skip(); return acceptHexdigs(8);
				default: return false;
			}
		}

	private:

		const char* data_;

		Size pos_;
		Size end_;
};


class Tokenizer;
class Token
{
	friend Tokenizer;

	public:

		Size pos() const
		{
			return pos_;
		}

		Size size() const
		{
			return size_;
		}

		bool isEof() const
		{
			return type_ == Type::eof;
		}

		bool isKey() const
		{
			return type_ == Type::key;
		}

		bool isValue() const
		{
			return type_ != Type::key
				&& type_ != Type::eof
				&& type_ != Type::bad;
		}

		bool read(bool& target) const
		{
			switch (type_)
			{
				case Type::boolNo: target = false; return true;
				case Type::boolYes: target = true; return true;
				default: return false;
			}
		}

		template<typename T, IsInt<T> = true>
		bool read(T& target) const
		{
			switch (type_)
			{
				case Type::numIntNeg:
					if constexpr (std::is_unsigned_v<T>)
						return false;
					[[fallthrough]];
				case Type::numIntPos: return readInt(target, 10, 0);
				case Type::numHex:    return readInt(target, 16, 2);
				default: return false;
			}
		}

		template<typename T, IsFloat<T> = true>
		bool read(T& target) const
		{
			switch (type_)
			{
				case Type::numIntPos:
				case Type::numIntNeg:
				case Type::numFloat: return readFloat<T>(target);
				default: return false;
			}
		}

		bool read(std::string& target) const
		{
			switch (type_)
			{
				case Type::strLiteral: return readLiteralString(target);
				case Type::strEscaped: return readEscapedString(target);
				default: return false;
			}
		}

		bool read(std::string_view& target) const
		{
			switch (type_)
			{
				case Type::strLiteral: return readLiteralString(target);
				default: return false;
			}
		}

	private:

		enum class Type
		{
			bad,
			eof,
			key,
			boolNo,
			boolYes,
			numHex,
			numIntPos,
			numIntNeg,
			numFloat,
			strLiteral,
			strEscaped
		};

		const char* data_;

		Size pos_;
		Size size_;
		Type type_;

		Token(const char* data, Size pos, Size size, Type type) :
			data_{data},
			pos_{pos},
			size_{size},
			type_{type}
		{}

		template<typename T>
		bool readInt(T& target, int base, int prefix) const
		{
			T i{};
			const char* const begin{data_ + pos_ + prefix};
			const char* const end{data_ + pos_ + size_};
			auto result{std::from_chars(begin, end, i, base)};

			if (result.ec != std::errc{} || result.ptr != end)
				return false;

			target = i;
			return true;
		}

		template<typename T>
		bool readFloat(T& target) const
		{
			// TODO: Replace with C++17 std::from_chars()
			errno = 0;
			char* end{};
			auto f{std::strtod(data_ + pos_, &end)};

			if (errno
				|| end != data_ + pos_ + size_
				|| f < std::numeric_limits<T>::lowest()
				|| f > std::numeric_limits<T>::max()
				|| std::isnan(f))
				return false;

			target = static_cast<T>(f);
			return true;
		}

		template<typename T>
		bool readLiteralString(T& target) const
		{
			target = T{data_ + pos_ + 1, size_ - 2};
			return true;
		}

		bool readEscapedString(std::string& target) const
		{
			enum class State{ copy, esc, hex };
			State state{State::copy};

			int hexDigs{0};
			char32_t hexVal{0};

			std::string out{};
			out.reserve(size_ - 2);

			const Size begin{pos_ + 1};
			const Size end{pos_ + size_ - 1};
			for (Size i{begin}; i < end; ++i)
			{
				const char c{data_[i]};
				switch (state)
				{
					case State::copy:
						if (c == '\\')
							state = State::esc;
						else
							out.push_back(c);
						break;

					case State::esc:
						switch (c)
						{
							case '\\': out.push_back('\\'); state = State::copy; break;
							case '"':  out.push_back('"');  state = State::copy; break;
							case 'n':  out.push_back('\n'); state = State::copy; break;
							case 'r':  out.push_back('\r'); state = State::copy; break;
							case 't':  out.push_back('\t'); state = State::copy; break;
							case 'u':  hexDigs = 4; state = State::hex; break;
							case 'U':  hexDigs = 8; state = State::hex; break;
							default: return false;
						}
						break;

					case State::hex:
						hexVal *= 16;
						if      ('0' <= c && c <= '9') hexVal += c - '0';
						else if ('A' <= c && c <= 'F') hexVal += c - 'A' + 10;
						else if ('a' <= c && c <= 'f') hexVal += c - 'a' + 10;
						else return false;

						if (--hexDigs < 1)
						{
							if (!pushUtf8(out, hexVal))
								return false;

							hexVal = 0;
							state = State::copy;
						}
						break;
				}
			}

			if (state != State::copy)
				return false;

			target = out;
			return true;
		}

		bool pushUtf8(std::string& s, char32_t c) const
		{
			if (c <= 0x7F)
			{
				s.push_back(static_cast<char>(c));
			}
			else if (c <= 0x7FF)
			{
				s.push_back(static_cast<char>(0xC0 | (c >> 6 & 0x1F)));
				s.push_back(static_cast<char>(0x80 | (c      & 0x3F)));
			}
			else if (0xD800 <= c && c <= 0xDFFF)
			{
				return false;
			}
			else if (c <= 0xFFFF)
			{
				s.push_back(static_cast<char>(0xE0 | (c >> 12 & 0x0F)));
				s.push_back(static_cast<char>(0x80 | (c >>  6 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c       & 0x3F)));
			}
			else if (c <= 0x10FFFF)
			{
				s.push_back(static_cast<char>(0xF0 | (c >> 18 & 0x07)));
				s.push_back(static_cast<char>(0x80 | (c >> 12 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c >>  6 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c       & 0x3F)));
			}
			else
				return false;

			return true;
		}
};


class Tokenizer
{
	using Type = Token::Type;

	public:

		Tokenizer(Stream stream, bool skipUtf8Bom = false) :
			stream_{std::move(stream)}
		{
			if (skipUtf8Bom
				&& stream_.peek()  == '\xEF'
				&& stream_.peek(1) == '\xBB'
				&& stream_.peek(2) == '\xBF')
				stream_.skip(3);
		}

		Token get()
		{
			while (isWs(stream_.peek()))
				stream_.skip();

			if (stream_.isEof())
				return {stream_.data(), stream_.pos(), 0, Type::eof};

			tokenPos_ = stream_.pos();
			switch (stream_.peek())
			{
				case '-':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					return scanDec();

				case '0':
					return (stream_.peek(1) == 'x')
						? scanHex()
						: scanDec();

				case 'n':
					return (stream_.peek(1) == 'o' && stream_.peek(2) != ':')
						? scanNo()
						: scanOther();

				case 'y':
					return (stream_.peek(1) == 'e' && stream_.peek(2) == 's' && stream_.peek(3) != ':')
						? scanYes()
						: scanOther();

				case '"':
					return scanString();

				default:
					return scanOther();
			}
		}

	private:

		Stream stream_;
		Size tokenPos_{0};

		Token make(Type type, bool isWsTerminated = false) const
		{
			if (isWsTerminated && !stream_.isEof() && !isWs(stream_.peek()))
				type = Type::bad;

			return {stream_.data(), tokenPos_, stream_.pos() - tokenPos_, type};
		}

		Token scanDec()
		{
			Type type{Type::numIntPos};

			if (stream_.accept('-'))
				type = Type::numIntNeg;

			if (!stream_.acceptDigits())
				return make(Type::bad);

			if (stream_.accept('.'))
			{
				type = Type::numFloat;
				if (!stream_.acceptDigits())
					return make(Type::bad);
			}

			if (stream_.accept('E') || stream_.accept('e'))
			{
				type = Type::numFloat;
				stream_.accept('-');
				if (!stream_.acceptDigits())
					return make(Type::bad);
			}

			return make(type, true);
		}

		Token scanHex()
		{
			stream_.skip(2);

			if (!stream_.acceptHexdigs())
				return make(Type::bad);

			return make(Type::numHex, true);
		}

		Token scanNo()
		{
			stream_.skip(2);
			return make(Type::boolNo, true);
		}

		Token scanYes()
		{
			stream_.skip(3);
			return make(Type::boolYes, true);
		}

		Token scanString()
		{
			Type type{Type::strLiteral};

			stream_.skip();
			while (!stream_.isEof() && stream_.peek() != '"')
			{
				if (stream_.accept('\\'))
				{
					type = Type::strEscaped;
					if (!stream_.acceptEscape())
						return make(Type::bad);
				}
				else
					if (!stream_.acceptScalar())
						return make(Type::bad);
			}

			if (!stream_.accept('"'))
				return make(Type::bad);

			return make(type, true);
		}

		Token scanOther()
		{
			if (isAlpha(stream_.peek()))
			{
				stream_.skip();
				while (isKeyChar(stream_.peek()))
					stream_.skip();
				if (stream_.peek() == ':')
				{
					Token token{make(Type::key)};
					stream_.skip();
					return token;
				}
			}
			return make(Type::bad);
		}
};


class Buffer;
class Lookup
{
	friend Buffer;

	// -----------------------------
	// KEYNAME: VALUE       NEXTKEY:
	// |------^------^------^-------
	// pos  colon  cursor  size

	Size pos;
	Size colon;
	Size cursor;
	Size size;

	Lookup(Size pos, Size colon, Size size) :
		pos{pos},
		colon{colon},
		cursor{size},
		size{size}
	{}

	std::string_view keyView(const char* data) const
	{
		return {data + pos, colon};
	}

	std::string_view dumpView(const char* data) const
	{
		return {data + pos, cursor};
	}

	struct Less
	{
		const char* data;

		bool operator()(const Lookup& a, const Lookup& b) const
		{
			return a.keyView(data) < b.keyView(data);
		}

		bool operator()(const Lookup& a, const std::string_view& b) const
		{
			return a.keyView(data) < b;
		}
	};

	struct Equal
	{
		const char* data;

		bool operator()(const Lookup& a, const Lookup& b) const
		{
			return a.keyView(data) == b.keyView(data);
		}

		bool operator()(const Lookup& a, const std::string_view& b) const
		{
			return a.keyView(data) == b;
		}
	};
};


class Buffer
{
	public:

		Buffer(std::string data, std::size_t maxItemCount) :
			maxItemCount_{maxItemCount}
		{
			if (data.size() > std::numeric_limits<Size>::max())
				return;

			std::vector<Lookup> lookups{};
			lookups.reserve(maxItemCount_ > 0 ? maxItemCount_ : 64);

			Stream stream{data.data(), 0, static_cast<Size>(data.size())};
			Tokenizer tokenizer{stream, true};
			Size prevKeyPos{0};
			Size prevKeySize{0};

			while (true)
			{
				const Token token{tokenizer.get()};

				if (token.isKey() || token.isEof())
				{
					if (prevKeySize != 0)
					{
						const Size size{token.pos() - prevKeyPos};
						const Lookup lookup{prevKeyPos, prevKeySize, size};
						if (maxItemCount_ > 0 && lookups.size() >= maxItemCount)
							return;
						lookups.push_back(lookup);
					}

					if (token.isEof())
						break;

					prevKeyPos = token.pos();
					prevKeySize = token.size();
				}
				else if (!token.isValue())
					return;
				else if (prevKeySize == 0)
					return;
			}

			// Sort items
			const Lookup::Less less{data.data()};
			std::sort(lookups.begin(), lookups.end(), less);

			// Check duplicate key
			const Lookup::Equal equal{data.data()};
			auto it{std::adjacent_find(lookups.begin(), lookups.end(), equal)};
			if (it != lookups.end())
				return;

			data_ = std::move(data);
			lookups_ = std::move(lookups);
			isOk_ = true;
		}

		explicit operator bool() const
		{
			return isOk_;
		}

		Lookup& operator[](std::string_view key)
		{
			const Lookup::Less less{data_.data()};
			const Lookup::Equal equal{data_.data()};
			auto it{std::lower_bound(lookups_.begin(), lookups_.end(), key, less)};

			if (it != lookups_.end() && equal(*it, key))
				return *it;

			if (maxItemCount_ > 0 && lookups_.size() >= maxItemCount_)
				return null_;

			if (!isKey(key))
				return null_;

			const Size dataMax{std::numeric_limits<Size>::max()};
			const Size dataSize{static_cast<Size>(data_.size())};

			if (key.size() >= dataMax - dataSize)
				return null_;

			const Size pos{static_cast<Size>(data_.size())};
			const Size colon{static_cast<Size>(key.size())};

			data_.append(key);
			data_.push_back(':');

			Lookup lookup{pos, colon, colon+1};
			return *(lookups_.insert(it, lookup));
		}

		void clear(Lookup& lookup)
		{
			if (lookup.colon == 0)
				return;

			lookup.cursor = lookup.colon + 1;
		}

		bool isOk(Lookup& lookup) const
		{
			return lookup.colon != 0;
		}

		Tokenizer tokenize(Lookup& lookup) const
		{
			if (lookup.colon == 0)
				return {Stream{data_.data(), 0, 0}};

			const Size begin{lookup.pos + lookup.colon + 1};
			const Size end{lookup.pos + lookup.cursor};
			return {Stream{data_.data(), begin, end}};
		}

		std::string dump() const
		{
			Size size{0};

			for(const Lookup& lookup : lookups_)
			{
				std::string_view view{lookup.dumpView(data_.data())};
				while (isNonNlWs(view.back()))
					view.remove_suffix(1);

				size += view.size();
				if (view.back() != '\n')
					size += 1;
			}

			std::string out{};
			out.reserve(size);

			for(const Lookup& lookup : lookups_)
			{
				std::string_view view{lookup.dumpView(data_.data())};
				while (isNonNlWs(view.back()))
					view.remove_suffix(1);

				out.append(view);
				if (view.back() != '\n')
					out.push_back('\n');
			}

			return out;
		}

		bool write(Lookup& lookup, const bool& value)
		{
			return value
				? writeRaw(lookup, "yes", 3)
				: writeRaw(lookup, "no", 2);
		}

		template<typename T, IsInt<T> = true>
		bool write(Lookup& lookup, const T& value)
		{
			return write(lookup, IntValue<T>{value, false, 0});
		}

		template<typename T>
		bool write(Lookup& lookup, const IntValue<T>& value)
		{
			const int base{value.isHex ? 16 : 10};
			const int width{std::clamp(value.width, 1, 16)};

			// The digits are written in the second half,
			// the hex prefix and padding in the first half.
			std::array<char, 48> temp;  // Enough for int64
			char* begin{temp.data() + temp.size()/2};
			char* end{temp.data() + temp.size()};
			auto result{std::to_chars(begin, end, value.value, base)};

			if (result.ec != std::errc{})
				return false;

			if (value.isHex)
			{
				int digits{static_cast<int>(result.ptr - begin)};
				int prefix{2 + std::max(0, width - digits)};
				while (begin != temp.data() && --prefix >= 0)
					*(--begin) = '0';
				*(begin + 1) = 'x';
			}

			return writeRaw(lookup, begin, result.ptr - begin);
		}

		template<typename T, IsFloat<T> = true>
		bool write(Lookup& lookup, const T& value)
		{
			return write(lookup, FloatValue<T>{value, 6, false});
		}

		template<typename T>
		bool write(Lookup& lookup, const FloatValue<T>& value)
		{
			if (std::isinf(value.value) || std::isnan(value.value))
				return false;

			const int precision{std::clamp(value.precision, 1, 24)};

			// TODO: Replace with C++17 std::to_chars()
			std::ostringstream stream{};
			stream.imbue(std::locale::classic());
			stream.precision(precision);
			if (value.isFixed)
				stream << std::fixed;
			stream << static_cast<double>(value.value);
			const std::string string{stream.str()};

			return writeRaw(lookup, string.data(), string.size());
		}

		bool write(Lookup& lookup, const Whitespace& value)
		{
			if (!isWs(value.value))
				return false;

			if (value.count < 1)
				return true;

			return writeRaw(lookup, value.value, value.count);
		}

		bool write(Lookup& lookup, const char* const& value)
		{
			return write(lookup, std::string_view{value});
		}

		bool write(Lookup& lookup, const std::string_view& value)
		{
			return writeRawString(lookup, value.data(), value.size());
		}

	private:

		std::string data_{};

		// INVARIANT: Lookups are sorted in ascending order.
		// INVARIANT: Lookups have unique keys.
		std::vector<Lookup> lookups_{};
		Lookup null_{0, 0, 0};

		std::size_t maxItemCount_{0};
		bool isOk_{false};

		bool writeRaw(Lookup& lookup, char ch, Size count)
		{
			if (lookup.colon == 0)
				return false;

			if (!reserveRaw(lookup, count))
				return false;

			replaceRaw(lookup, ch, count);
			return true;
		}

		bool writeRaw(Lookup& lookup, const char* data, Size count)
		{
			if (lookup.colon == 0)
				return false;

			if (isWs(data_[lookup.pos + lookup.cursor - 1]))
			{
				if (!reserveRaw(lookup, count))
					return false;
			}
			else
			{
				if (!canAdd(count, 1))
					return false;
				if (!reserveRaw(lookup, count + 1))
					return false;
				replaceRaw(lookup, ' ');
			}

			replaceRaw(lookup, data, count);
			return true;
		}

		bool writeRawString(Lookup& lookup, const char* data, Size count)
		{
			if (lookup.colon == 0)
				return false;

			Size escCount{0};
			Stream stream{data, 0, count};

			while (!stream.isEof())
			{
				if (stream.accept('"') || stream.accept('\\'))
					++escCount;
				else if (!stream.acceptScalar())
					return false;
			}

			if (!canAdd(count, escCount))
				return false;

			if (isWs(data_[lookup.pos + lookup.cursor - 1]))
			{
				if (!canAdd(count + escCount, 2))
					return false;
				if (!reserveRaw(lookup, count + escCount + 2))
					return false;
			}
			else
			{
				if (!canAdd(count + escCount, 3))
					return false;
				if (!reserveRaw(lookup, count + escCount + 3))
					return false;
				replaceRaw(lookup, ' ');
			}

			replaceRaw(lookup, '"');

			if (escCount == 0)
				replaceRaw(lookup, data, count);
			else
			{
				for (Size i{0}; i < count; ++i)
				{
					if (data[i] == '"' || data[i] == '\\')
						replaceRaw(lookup, '\\');
					replaceRaw(lookup, data[i]);
				}
			}

			replaceRaw(lookup, '"');
			return true;
		}

		bool canAdd(Size a, Size b) const
		{
			return a <= std::numeric_limits<Size>::max() - b;
		}

		bool reserveRaw(Lookup& lookup, Size count)
		{
			const Size itemVacant{lookup.size - lookup.cursor};

			if (count <= itemVacant)
				return true;

			const Size dataMax{std::numeric_limits<Size>::max()};
			const Size dataSize{static_cast<Size>(data_.size())};
			const Size dataVacant{dataMax - dataSize};
			const Size itemNeeded{count - itemVacant};

			if (itemNeeded > dataVacant)
				return false;

			// Add extra bytes to postpone the next costly insertion.
			const Size itemUsed{lookup.size - lookup.colon + itemNeeded};
			const Size extraMax{dataVacant - itemNeeded};
			const Size extraSize{std::min(std::max<Size>(16, itemUsed), extraMax)};
			const Size addSize{itemNeeded + extraSize};
			const Size addPos{lookup.pos + lookup.size};

			if (addPos == data_.size())
				data_.append(addSize, char{});
			else
			{
				data_.insert(addPos, addSize, char{});
				for (Lookup& lookup : lookups_)
					if (lookup.pos >= addPos)
						lookup.pos += addSize;
			}

			lookup.size += addSize;
			return true;
		}

		void replaceRaw(Lookup& lookup, char c, Size count = 1)
		{
			data_.replace(lookup.pos + lookup.cursor, count, count, c);
			lookup.cursor += count;
		}

		void replaceRaw(Lookup& lookup, const char* data, Size count)
		{
			data_.replace(lookup.pos + lookup.cursor, count, data, count);
			lookup.cursor += count;
		}
};


// Public types
// ------------

class Document;
class Item
{
	friend Document;

	public:

		// Checks if the item is active after construction,
		// or if the previous read or write was successul.
		explicit operator bool() const
		{
			return isOk_ && buffer_.isOk(lookup_);
		}

		// Reads the next value and assigns it to a standard bool,
		// integral, floating-point, string, or string_view variable.
		// If the read fails, the target variable is left unchanged.
		// A string_view cannot contain any escape sequence and only
		// remains valid until the document is altered.
		// The read position is reset after each write.
		template<typename T>
		Item& operator>>(T& target)
		{
			if (!isReading_)
			{
				tokenizer_ = buffer_.tokenize(lookup_);
				isReading_ = true;
			}

			isOk_ = tokenizer_.get().read(target);
			return *this;
		}

		// Appends a standard bool, integral, floating-point,
		// string, or string_view value. Invalid values are ignored.
		// For strings, any double quote or backslash is escaped.
		// The write position is reset after each read.
		template<typename T>
		Item& operator<<(const T& value)
		{
			if (isReading_)
			{
				buffer_.clear(lookup_);
				isReading_ = false;
			}

			isOk_ = buffer_.write(lookup_, value);
			return *this;
		}

	private:

		Buffer& buffer_;
		Lookup& lookup_;

		Tokenizer tokenizer_;

		bool isOk_{true};
		bool isReading_{true};

		Item(Buffer& buffer, Lookup& lookup) :
			buffer_{buffer},
			lookup_{lookup},
			tokenizer_{buffer_.tokenize(lookup_)}
		{}
};


class Document
{
	public:

		// Constructs an empty document.
		Document() :
			Document{std::string{}}
		{}

		// Takes ownership of a KCV string and parses it.
		// If the parsing fails, or the non-zero maxItemCount
		// is exceeded, an empty document is constructed instead.
		// The string size is limited to 4 GiB.
		explicit Document(std::string data, std::size_t maxItemCount = 0) :
			buffer_{std::move(data), maxItemCount}
		{}

		// Checks if the constructor accepted the data string.
		explicit operator bool() const
		{
			return static_cast<bool>(buffer_);
		}

		// Retrieves an item. If the key does not exist, a new
		// item is inserted. If the key is invalid, or the non-zero
		// maxItemCount is exceeded, an inactive item is returned.
		//
		// IMPORTANT: Only use the most recent Item instance.
		// Old Item instances may contain invalidated references.
		//
		Item operator[](std::string_view key)
		{
			return {buffer_, buffer_[key]};
		}

		// Converts the document to a string.
		// The items are ordered lexicographically.
		std::string dump() const
		{
			return buffer_.dump();
		}

	private:

		Buffer buffer_;
};


} // namespace detail


using detail::Document;
using detail::Item;

using detail::hex;
using detail::fixed;
using detail::general;
using detail::nl;
using detail::sp;
using detail::tab;


} // namespace kcv

#endif // KCV_KCV_HPP_INCLUDED
