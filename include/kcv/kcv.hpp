// kcv-cpp 0.2.0
// A lightweight KCV library for C++17
// https://github.com/sevmeyer/kcv-cpp
//
// Copyright 2020 Severin Meyer
// Distributed under the Boost Software License 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#ifndef KCV_KCV_HPP_INCLUDED
#define KCV_KCV_HPP_INCLUDED


#include <cerrno>       // errno
#include <cmath>        // isinf, isnan
#include <cstddef>      // size_t
#include <cstdint>      // uint32_t
#include <cstdlib>      // strtod
#include <algorithm>    // adjacent_find, clamp, lower_bound, max, min, sort
#include <array>        // array
#include <charconv>     // from_chars, to_chars
#include <functional>   // less
#include <locale>       // locale
#include <limits>       // numeric_limits
#include <map>          // map
#include <sstream>      // fixed, ostringstream
#include <string>       // string
#include <string_view>  // string_view
#include <system_error> // errc
#include <type_traits>  // enable_if, is_floating_point, is_integral, is_unsigned
#include <utility>      // move


namespace kcv    {
namespace detail {


template<typename T>
using IsInt = typename std::enable_if_t<
	std::is_integral_v<T>, bool>;

template<typename T>
using IsFloat = typename std::enable_if_t<
	std::is_floating_point_v<T>, bool>;


// Character tests
// ---------------

inline bool isWs(char c)
{
	return c == ' ' || c == '\n' || c == '\r' || c == '\t';
}

inline bool isDigit(char c)
{
	return ('0' <= c && c <= '9');
}

inline bool isAlpha(char c)
{
	return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z');
}

inline bool isHexdig(char c)
{
	return isDigit(c) || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f');
}

inline bool isKeyChar(char c)
{
	return isAlpha(c) || isDigit(c) || c == '-' || c == '.' || c == '_';
}


// Value formatters
// ----------------

template<typename T>
struct IntValue
{
	T value;
	bool isHex;
	int width;
};

template<typename T>
struct FloatValue
{
	T value;
	int precision;
	bool isFixed;
};

struct Whitespace
{
	char value;
	int count;
};

// Writes a zero-padded hexadecimal integer.
template<typename T>
inline IntValue<T> hex(T value, int width = 1)
{
	return {value, true, width};
}

// Writes a floating-point value with a fixed
// number of digits after the decimal point.
template<typename T>
inline FloatValue<T> fixed(T value, int precision = 6)
{
	return {value, precision, true};
}

// Writes a floating-point value in general notation.
template<typename T>
inline FloatValue<T> general(T value, int precision = 6)
{
	return {value, precision, false};
}

// Writes newlines.
inline Whitespace nl(int count = 1)
{
	return {'\n', count};
}

// Writes spaces.
inline Whitespace sp(int count = 1)
{
	return {' ', count};
}

// Writes tabs.
inline Whitespace tab(int count = 1)
{
	return {'\t', count};
}


// Private types
// -------------

class Stream
{
	// Accepts nullptr.
	// Bounds-checked.

	public:

		Stream() = default;

		Stream(const char* data, std::size_t count, std::size_t pos = 0) :
			data_{data},
			end_{count},
			pos_{std::min(pos, count)}
		{}

		explicit Stream(std::string_view view) :
			Stream{view.data(), view.size()}
		{}

		const char* data() const
		{
			return data_;
		}

		std::size_t pos() const
		{
			return pos_;
		}

		bool eof() const
		{
			return pos_ >= end_;
		}

		char peek() const
		{
			return pos_ < end_ ? data_[pos_] : 0;
		}

		char peek(std::size_t offset) const
		{
			return (end_ - pos_ > offset) ? data_[pos_ + offset] : 0;
		}

		void skip(std::size_t count = 1)
		{
			pos_ += std::min(end_ - pos_, count);
		}

		bool accept(char c)
		{
			if (peek() != c)
				return false;
			skip();
			return true;
		}

		bool acceptDigits()
		{
			if (!isDigit(peek()))
				return false;
			skip();
			while (isDigit(peek()))
				skip();
			return true;
		}

		bool acceptHexdigs()
		{
			if (!isHexdig(peek()))
				return false;
			skip();
			while (isHexdig(peek()))
				skip();
			return true;
		}

		bool acceptHexdigs(std::size_t count)
		{
			while (count-- > 0)
			{
				if (!isHexdig(peek()))
					return false;
				skip();
			}
			return true;
		}

		bool acceptScalar()
		{
			// https://www.unicode.org/versions/Unicode12.1.0/
			// Table 3-7. Well-Formed UTF-8 Byte Sequences
			//
			// Code Points    Byte1  Byte2  Byte3  Byte4
			// 000000-00007F  00-7F
			// 000080-0007FF  C2-DF  80-BF
			// 000800-000FFF  E0     A0-BF  80-BF
			// 001000-00CFFF  E1-EC  80-BF  80-BF
			// 00D000-00D7FF  ED     80-9F  80-BF
			// 00E000-00FFFF  EE-EF  80-BF  80-BF
			// 010000-03FFFF  F0     90-BF  80-BF  80-BF
			// 040000-0FFFFF  F1-F3  80-BF  80-BF  80-BF
			// 100000-10FFFF  F4     80-8F  80-BF  80-BF

			unsigned char b{static_cast<unsigned char>(peek())};

			if (b <= 0x7F)
			{
				skip();
				return true;
			}

			unsigned char min{0x80};
			unsigned char max{0xBF};
			int count{1};

			if      (0xC2 <= b &&  b <= 0xDF) { count = 2; }
			else if (0xE0 == b) { min = 0xA0;   count = 3; }
			else if (0xE1 <= b &&  b <= 0xEC) { count = 3; }
			else if (0xED == b) { max = 0x9F;   count = 3; }
			else if (0xEE <= b &&  b <= 0xEF) { count = 3; }
			else if (0xF0 == b) { min = 0x90;   count = 4; }
			else if (0xF1 <= b &&  b <= 0xF3) { count = 4; }
			else if (0xF4 == b) { max = 0x8F;   count = 4; }
			else return false;

			skip();
			while (--count > 0)
			{
				b = static_cast<unsigned char>(peek());
				if (b < min || max < b)
					return false;
				min = 0x80;
				max = 0xBF;
				skip();
			}

			return true;
		}

		bool acceptEscape()
		{
			switch (peek())
			{
				case '\\':
				case '"':
				case 'n':
				case 'r':
				case 't': skip(); return true;
				case 'u': skip(); return acceptHexdigs(4);
				case 'U': skip(); return acceptHexdigs(8);
				default:          return false;
			}
		}

	private:

		const char* data_{nullptr};
		std::size_t end_{0};
		std::size_t pos_{0};
};


class Token
{
	public:

		enum class Type
		{
			bad,
			eof,
			key,
			boolNo,
			boolYes,
			numHex,
			numIntPos,
			numIntNeg,
			numFloat,
			strLiteral,
			strEscaped
		};

		Token(const char* data, std::size_t pos, std::size_t size, Type type) :
			data_{data},
			pos_{pos},
			size_{size},
			type_{type}
		{}

		std::size_t pos() const
		{
			return pos_;
		}

		std::size_t size() const
		{
			return size_;
		}

		bool isEof() const
		{
			return type_ == Type::eof;
		}

		bool isKey() const
		{
			return type_ == Type::key;
		}

		bool isValue() const
		{
			return type_ != Type::key
				&& type_ != Type::eof
				&& type_ != Type::bad;
		}

		bool read(bool& target) const
		{
			switch (type_)
			{
				case Type::boolNo: target = false; return true;
				case Type::boolYes: target = true; return true;
				default: return false;
			}
		}

		template<typename T, IsInt<T> = true>
		bool read(T& target) const
		{
			switch (type_)
			{
				case Type::numIntNeg:
					if constexpr (std::is_unsigned_v<T>)
						return false;
					[[fallthrough]];
				case Type::numIntPos: return rawInt(target, 10, 0);
				case Type::numHex:    return rawInt(target, 16, 2);
				default: return false;
			}
		}

		template<typename T, IsFloat<T> = true>
		bool read(T& target) const
		{
			switch (type_)
			{
				case Type::numIntPos:
				case Type::numIntNeg:
				case Type::numFloat: return rawFloat<T>(target);
				default: return false;
			}
		}

		bool read(std::string& target) const
		{
			switch (type_)
			{
				case Type::strLiteral: return rawLiteralString(target);
				case Type::strEscaped: return rawEscapedString(target);
				default: return false;
			}
		}

		bool read(std::string_view& target) const
		{
			switch (type_)
			{
				case Type::strLiteral: return rawLiteralString(target);
				default: return false;
			}
		}

	private:

		const char* data_;
		std::size_t pos_;
		std::size_t size_;
		Type type_;

		template<typename T>
		bool rawInt(T& target, int base, int prefix) const
		{
			T i{};
			const char* const begin{data_ + pos_ + prefix};
			const char* const end{data_ + pos_ + size_};
			auto result{std::from_chars(begin, end, i, base)};

			if (result.ec != std::errc{} || result.ptr != end)
				return false;

			target = i;
			return true;
		}

		template<typename T>
		bool rawFloat(T& target) const
		{
			// TODO: Replace with C++17 std::from_chars()
			errno = 0;
			char* end{};
			auto f{std::strtod(data_ + pos_, &end)};

			if (errno
				|| end != data_ + pos_ + size_
				|| f < std::numeric_limits<T>::lowest()
				|| f > std::numeric_limits<T>::max()
				|| std::isnan(f))
				return false;

			target = static_cast<T>(f);
			return true;
		}

		template<typename T>
		bool rawLiteralString(T& target) const
		{
			target = T{data_ + pos_ + 1, size_ - 2};
			return true;
		}

		bool rawEscapedString(std::string& target) const
		{
			enum class State{ copy, esc, hex };
			State state{State::copy};

			int hexDigs{0};
			char32_t hexVal{0};

			std::string out{};
			out.reserve(size_ - 2);

			for (std::size_t i{1}; i < size_ - 1; ++i)
			{
				const char c{data_[pos_ + i]};
				switch (state)
				{
					case State::copy:
						if (c == '\\')
							state = State::esc;
						else
							out.push_back(c);
						break;

					case State::esc:
						switch (c)
						{
							case '\\': out.push_back('\\'); state = State::copy; break;
							case '"':  out.push_back('"');  state = State::copy; break;
							case 'n':  out.push_back('\n'); state = State::copy; break;
							case 'r':  out.push_back('\r'); state = State::copy; break;
							case 't':  out.push_back('\t'); state = State::copy; break;
							case 'u':  hexDigs = 4; state = State::hex; break;
							case 'U':  hexDigs = 8; state = State::hex; break;
							default: return false;
						}
						break;

					case State::hex:
						hexVal *= 16;
						if      ('0' <= c && c <= '9') hexVal += c - '0';
						else if ('A' <= c && c <= 'F') hexVal += c - 'A' + 10;
						else if ('a' <= c && c <= 'f') hexVal += c - 'a' + 10;
						else return false;

						if (--hexDigs < 1)
						{
							if (!pushUtf8(out, hexVal))
								return false;

							hexVal = 0;
							state = State::copy;
						}
						break;
				}
			}

			if (state != State::copy)
				return false;

			target = std::move(out);
			return true;
		}

		bool pushUtf8(std::string& s, char32_t c) const
		{
			if (c <= 0x7F)
			{
				s.push_back(static_cast<char>(c));
			}
			else if (c <= 0x7FF)
			{
				s.push_back(static_cast<char>(0xC0 | (c >> 6 & 0x1F)));
				s.push_back(static_cast<char>(0x80 | (c      & 0x3F)));
			}
			else if (0xD800 <= c && c <= 0xDFFF)
			{
				return false;
			}
			else if (c <= 0xFFFF)
			{
				s.push_back(static_cast<char>(0xE0 | (c >> 12 & 0x0F)));
				s.push_back(static_cast<char>(0x80 | (c >>  6 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c       & 0x3F)));
			}
			else if (c <= 0x10FFFF)
			{
				s.push_back(static_cast<char>(0xF0 | (c >> 18 & 0x07)));
				s.push_back(static_cast<char>(0x80 | (c >> 12 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c >>  6 & 0x3F)));
				s.push_back(static_cast<char>(0x80 | (c       & 0x3F)));
			}
			else
				return false;

			return true;
		}
};


class Tokenizer
{
	using Type = Token::Type;

	public:

		Tokenizer() = default;

		explicit Tokenizer(Stream stream, bool skipUtf8Bom = false) :
			stream_{std::move(stream)}
		{
			if (skipUtf8Bom
				&& stream_.peek()  == '\xEF'
				&& stream_.peek(1) == '\xBB'
				&& stream_.peek(2) == '\xBF')
				stream_.skip(3);
		}

		std::size_t pos() const
		{
			return stream_.pos();
		}

		Token get()
		{
			while (isWs(stream_.peek()))
				stream_.skip();

			tokenPos_ = stream_.pos();

			if (stream_.eof())
				return make(Type::eof);

			switch (stream_.peek())
			{
				case '-':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					return scanDec();
				case '0':
					return (stream_.peek(1) == 'x')
						? scanHex()
						: scanDec();
				case 'n':
					return (stream_.peek(1) == 'o' && stream_.peek(2) != ':')
						? scanNo()
						: scanOther();
				case 'y':
					return (stream_.peek(1) == 'e' && stream_.peek(2) == 's' && stream_.peek(3) != ':')
						? scanYes()
						: scanOther();
				case '"':
					return scanString();
				default:
					return scanOther();
			}
		}

	private:

		Stream stream_{};
		std::size_t tokenPos_{0};

		Token make(Type type, bool isWsTerminated = false) const
		{
			if (isWsTerminated && !stream_.eof() && !isWs(stream_.peek()))
				type = Type::bad;

			return {stream_.data(), tokenPos_, stream_.pos() - tokenPos_, type};
		}

		Token scanDec()
		{
			Type type{Type::numIntPos};

			if (stream_.accept('-'))
				type = Type::numIntNeg;

			if (!stream_.acceptDigits())
				return make(Type::bad);

			if (stream_.accept('.'))
			{
				type = Type::numFloat;
				if (!stream_.acceptDigits())
					return make(Type::bad);
			}

			if (stream_.accept('E') || stream_.accept('e'))
			{
				type = Type::numFloat;
				stream_.accept('-');
				if (!stream_.acceptDigits())
					return make(Type::bad);
			}

			return make(type, true);
		}

		Token scanHex()
		{
			stream_.skip(2);

			if (!stream_.acceptHexdigs())
				return make(Type::bad);

			return make(Type::numHex, true);
		}

		Token scanNo()
		{
			stream_.skip(2);
			return make(Type::boolNo, true);
		}

		Token scanYes()
		{
			stream_.skip(3);
			return make(Type::boolYes, true);
		}

		Token scanString()
		{
			Type type{Type::strLiteral};

			stream_.skip();
			while (!stream_.eof() && stream_.peek() != '"')
			{
				if (stream_.accept('\\'))
				{
					type = Type::strEscaped;
					if (!stream_.acceptEscape())
						return make(Type::bad);
				}
				else
					if (!stream_.acceptScalar())
						return make(Type::bad);
			}

			if (!stream_.accept('"'))
				return make(Type::bad);

			return make(type, true);
		}

		Token scanOther()
		{
			if (isAlpha(stream_.peek()))
			{
				stream_.skip();
				while (isKeyChar(stream_.peek()))
					stream_.skip();
				if (stream_.peek() == ':')
				{
					Token token{make(Type::key)};
					stream_.skip();
					return token;
				}
			}
			return make(Type::bad);
		}
};


class Appender
{
	public:

		explicit Appender(std::string& target) :
			target_{target}
		{}

		bool append(const Whitespace& value)
		{
			if (!isWs(value.value) || value.count < 1)
				return false;

			return rawWhitespace(value.value, value.count);
		}

		bool append(const bool& value)
		{
			return value ? rawValue("yes", 3) : rawValue("no", 2);
		}

		template<typename T, IsInt<T> = true>
		bool append(const T& value)
		{
			return append(IntValue<T>{value, false, 0});
		}

		template<typename T>
		bool append(const IntValue<T>& value)
		{
			if (value.isHex && value.value < 0)
				return false;

			// Write to temporary buffer. The digits are written in the
			// second half, the hex prefix and padding in the first half.
			constexpr int half{24}; // Enough for int64
			std::array<char, half*2> temp;

			char* begin{temp.data() + half};
			char* end{temp.data() + temp.size()};
			const int base{value.isHex ? 16 : 10};
			auto result{std::to_chars(begin, end, value.value, base)};

			if (result.ec != std::errc{})
				return false;

			if (value.isHex)
			{
				const int digits{static_cast<int>(result.ptr - begin)};
				int prefix{std::clamp(2 + value.width - digits, 2, half)};

				while (prefix-- > 2)
					*(--begin) = '0';
				*(--begin) = 'x';
				*(--begin) = '0';
			}

			return rawValue(begin, static_cast<std::size_t>(result.ptr - begin));
		}

		template<typename T, IsFloat<T> = true>
		bool append(const T& value)
		{
			return append(FloatValue<T>{value, 6, false});
		}

		template<typename T>
		bool append(const FloatValue<T>& value)
		{
			if (std::isinf(value.value) || std::isnan(value.value))
				return false;

			const int precision{std::clamp(value.precision, 1, 24)};

			// TODO: Replace with C++17 std::to_chars()
			std::ostringstream stream{};
			stream.imbue(std::locale::classic());
			stream.precision(precision);
			if (value.isFixed)
				stream << std::fixed;
			stream << static_cast<double>(value.value);
			const std::string temp{stream.str()};

			return rawValue(temp.data(), temp.size());
		}

		bool append(const char* const& value)
		{
			return append(std::string_view{value});
		}

		bool append(const std::string_view& value)
		{
			return rawString(value.data(), value.size());
		}

	private:

		std::string& target_;

		void rawSeparator()
		{
			if (!target_.empty() && !isWs(target_.back()))
				target_.push_back(' ');
		}

		bool rawWhitespace(char ch, std::size_t count)
		{
			target_.append(count, ch);
			return true;
		}

		bool rawValue(const char* data, std::size_t count)
		{
			rawSeparator();
			target_.append(data, count);
			return true;
		}

		bool rawString(const char* data, std::size_t count)
		{
			Stream stream{data, count};
			std::size_t escCount{0};

			while (!stream.eof())
			{
				if (stream.accept('"') || stream.accept('\\'))
					++escCount;
				else if (!stream.acceptScalar())
					return false;
			}

			rawSeparator();
			target_.push_back('"');

			if (escCount == 0)
				target_.append(data, count);
			else
			{
				for (std::size_t i{0}; i < count; ++i)
				{
					if (data[i] == '"' || data[i] == '\\')
						target_.push_back('\\');
					target_.push_back(data[i]);
				}
			}

			target_.push_back('"');
			return true;
		}
};


class Lookup
{
	public:

		struct Less
		{
			const char* data;

			bool operator()(const Lookup& a, const Lookup& b) const
			{
				return a.keyView(data) < b.keyView(data);
			}

			bool operator()(const Lookup& a, const std::string_view& b) const
			{
				return a.keyView(data) < b;
			}
		};

		struct Equal
		{
			const char* data;

			bool operator()(const Lookup& a, const Lookup& b) const
			{
				return a.keyView(data) == b.keyView(data);
			}

			bool operator()(const Lookup& a, const std::string_view& b) const
			{
				return a.keyView(data) == b;
			}
		};

		Lookup() = default;

		Lookup(std::size_t keyPos, std::size_t keySize, std::size_t itemSize)
		{
			if (keyPos > 0xFFFFFFFFu || keySize > 0xFFu || itemSize > 0xFFFFFFu)
				return;

			pos_   = static_cast<std::uint32_t>(keyPos);
			sizes_ = static_cast<std::uint32_t>(keySize | (itemSize << 8));
		}

		explicit operator bool() const
		{
			return sizes_ > 0;
		}

		std::string_view keyView(const char* data) const
		{
			return {data + pos_, sizes_ & 0xFF};
		}

		std::string_view valView(const char* data) const
		{
			const std::size_t valPos{pos_ + (sizes_ & 0xFF) + 1};
			const std::size_t valEnd{pos_ + (sizes_ >> 8)};
			return {data + valPos, valEnd - valPos};
		}

	private:

		std::uint32_t pos_{0};
		std::uint32_t sizes_{0};
		// Item size in FFFFFF00
		// Key  size in 000000FF
};


// Public types
// ------------

class Document;
class Item
{
	friend Document;

	public:

		// Checks if the item is active after construction,
		// or if the most recent read or write was successul.
		explicit operator bool() const
		{
			return values_ != nullptr && isOk_;
		}

		// Reads the next value and assigns it to a standard bool,
		// integral, floating-point, string, or string_view variable.
		// If the read fails, the target variable is left unchanged.
		// A string_view cannot contain any escape sequence and
		// remains valid until the item is altered.
		// Resets the write position.
		template<typename T>
		Item& operator>>(T& target)
		{
			if (values_ == nullptr)
				return *this;

			Tokenizer tokenizer{Stream{values_->data(), values_->size(), readPos_}};
			isOk_ = tokenizer.get().read(target);
			readPos_ = tokenizer.pos();
			isReading_ = true;
			return *this;

		}

		// Appends a standard bool, integral, floating-point,
		// string, or string_view value. Invalid values are ignored.
		// Within strings, any double quote or backslash is escaped.
		// Resets the read position.
		template<typename T>
		Item& operator<<(const T& value)
		{
			if (values_ == nullptr)
				return *this;

			if (isReading_)
				values_->clear();

			Appender appender{*values_};
			isOk_ = appender.append(value);
			readPos_ = 0;
			isReading_ = false;
			return *this;
		}

	private:

		std::string* values_{nullptr};
		std::size_t readPos_{0};
		bool isReading_{true};
		bool isOk_{true};

		Item() = default;

		explicit Item(std::string* values) :
			values_{values}
		{}
};


class Document
{
	// A general purpose class which owns and manages its data.
	// New items can be inserted. Values can be read and written.
	// Item lookup has logarithmic complexity.

	public:

		// Constructs an empty document.
		Document() :
			isOk_{true}
		{}

		// Parses a KCV string. If the parsing fails, or the non-zero
		// maxItemCount is exceeded, an empty document is constructed.
		explicit Document(std::string_view data, std::size_t maxItemCount = 0)
		{
			Map items{};

			Tokenizer tokenizer{Stream{data}, true};
			std::size_t keyPos{0};
			std::size_t keySize{0};

			while (true)
			{
				const Token token{tokenizer.get()};

				if (token.isKey() || token.isEof())
				{
					if (keySize != 0)
					{
						if (maxItemCount > 0 && items.size() >= maxItemCount)
							return;

						const std::size_t valPos{keyPos + keySize + 1};
						const std::size_t valSize{token.pos() - valPos};

						auto result{items.try_emplace(
							std::string{data.substr(keyPos, keySize)},
							std::string{data.substr(valPos, valSize)} )};

						if (!result.second)
							return;
					}

					if (token.isEof())
						break;

					keyPos = token.pos();
					keySize = token.size();
				}
				else if (!token.isValue())
					return;
				else if (keySize == 0)
					return;
			}

			items_ = std::move(items);
			isOk_ = true;
		}

		// Checks if the constructor accepted the data string.
		explicit operator bool() const
		{
			return isOk_;
		}

		// Retrieves an item. If the key does not exist, a new item is
		// inserted. If the key is invalid, an inactive item is returned.
		Item operator[](std::string_view key)
		{
			auto found{items_.find(key)};
			if (found != items_.end())
				return Item{&(found->second)};

			if (key.empty())
				return {};

			if (!isAlpha(key[0]))
				return {};

			for (std::size_t i{1}; i < key.size(); ++i)
				if (!isKeyChar(key[i]))
					return {};

			auto emplaced{items_.try_emplace(std::string{key}, std::string{})};
			return Item{&(emplaced.first->second)};
		}

		// Writes the document to a string.
		// The items are ordered lexicographically.
		std::string dump() const
		{
			std::size_t size{0};

			for(const auto& [key, values] : items_)
			{
				size += key.size();
				size += 1;
				if (!values.empty() && !isWs(values.front()))
					size += 1;
				size += values.size();
				if (values.empty() || values.back() != '\n')
					size += 1;
			}

			std::string out{};
			out.reserve(size);

			for(const auto& [key, values] : items_)
			{
				out.append(key);
				out.push_back(':');
				if (!values.empty() && !isWs(values.front()))
					out.push_back(' ');
				out.append(values);
				if (values.empty() || values.back() != '\n')
					out.push_back('\n');
			}

			return out;
		}

	private:

		using Map = std::map<std::string, std::string, std::less<>>;

		Map items_{};
		bool isOk_{false};
};


template<std::size_t>
class DocumentView;
class ItemView
{
	template<std::size_t>
	friend class DocumentView;

	public:

		// Checks if the item is active after construction,
		// or if the most recent read or write was successul.
		explicit operator bool() const
		{
			return isOk_;
		}

		// Reads the next value and assigns it to a standard bool,
		// integral, floating-point, string, or string_view variable.
		// If the read fails, the target variable is left unchanged.
		// A string_view cannot contain any escape sequence.
		template<typename T>
		ItemView& operator>>(T& target)
		{
			isOk_ = isOk_ && tokenizer_.get().read(target);
			return *this;
		}

	private:

		Tokenizer tokenizer_{};
		bool isOk_{false};

		ItemView() = default;

		explicit ItemView(Tokenizer tokenizer) :
			tokenizer_{tokenizer},
			isOk_{true}
		{}
};


template<std::size_t MaxItemCount>
class DocumentView
{
	// A read-only class which does not own or allocate data.
	// Remains valid as long as the provided data string_view.
	// Stores MaxItemCount*64 bits of metadata on the stack.
	// The data string size is limited to 4 GiB, the item
	// size to 16 MiB, and the key size to 255 bytes.
	// Item lookup has logarithmic complexity.

	public:

		// Constructs an empty document.
		DocumentView() :
			isOk_{true}
		{}

		// Parses a KCV string. If the parsing fails, or MaxItemCount
		// is exceeded, the document is considered empty.
		explicit DocumentView(std::string_view data)
		{
			Tokenizer tokenizer{Stream{data}, true};
			std::size_t keyPos{0};
			std::size_t keySize{0};

			while (true)
			{
				const Token token{tokenizer.get()};

				if (token.isKey() || token.isEof())
				{
					if (keySize != 0)
					{
						Lookup lookup{keyPos, keySize, token.pos() - keyPos};

						if (!lookup || end_ == lookups_.end())
							return;

						*end_++ = lookup;
					}

					if (token.isEof())
						break;

					keyPos = token.pos();
					keySize = token.size();
				}
				else if (!token.isValue())
					return;
				else if (keySize == 0)
					return;
			}

			// Sort items
			const Lookup::Less less{data.data()};
			std::sort(lookups_.begin(), end_, less);

			// Reject duplicate keys
			const Lookup::Equal equal{data.data()};
			if (std::adjacent_find(lookups_.begin(), end_, equal) != end_)
				return;

			data_ = data.data();
			isOk_ = true;
		}

		// Checks if the constructor accepted the data string.
		explicit operator bool() const
		{
			return isOk_;
		}

		// Retrieves an item. If the key does not exist,
		// an inactive item is returned.
		ItemView operator[](std::string_view key)
		{
			if (isOk_ && data_ != nullptr)
			{
				const Lookup::Less less{data_};
				const Lookup::Equal equal{data_};
				auto it{std::lower_bound(lookups_.begin(), end_, key, less)};

				if (it != end_ && equal(*it, key))
					return ItemView{Tokenizer{Stream{it->valView(data_)}}};
			}

			return {};
		}

	private:

		using Array = std::array<Lookup, MaxItemCount>;
		using ArrayIt = typename Array::iterator;

		const char* data_{nullptr};

		Array lookups_{};
		ArrayIt end_{lookups_.begin()};

		bool isOk_{false};
};

} // namespace detail


using detail::DocumentView;
using detail::ItemView;

using detail::Document;
using detail::Item;

using detail::hex;
using detail::fixed;
using detail::general;
using detail::nl;
using detail::sp;
using detail::tab;


} // namespace kcv

#endif // KCV_KCV_HPP_INCLUDED
